use crate::image::image_view::GenImageView;
use crate::image::image_view::ImageSize;
use crate::image::image_view::IsImageView;
use crate::image::mut_image::GenMutImage;
use crate::tensor::arc_tensor::ArcTensor;
use crate::tensor::element::IsStaticTensor;
use crate::tensor::element::IsTensorScalar;
use crate::tensor::element::SVec;
use crate::tensor::view::IsTensorLike;
use crate::tensor::view::IsTensorView;
use crate::tensor::view::TensorView;

/// Image of static tensors with shared ownership
#[derive(Debug, Clone)]
pub struct GenArcImage<
    const TOTAL_RANK: usize,
    const SRANK: usize,
    Scalar: IsTensorScalar + 'static,
    STensor: IsStaticTensor<Scalar, SRANK, ROWS, COLS, BATCH_SIZE> + 'static,
    const ROWS: usize,
    const COLS: usize,
    const BATCH_SIZE: usize,
> {
    /// underlying tensor
    pub tensor: ArcTensor<TOTAL_RANK, 2, SRANK, Scalar, STensor, ROWS, COLS, BATCH_SIZE>,
}

/// Image of scalar values
pub type ArcImage<Scalar> = GenArcImage<2, 0, Scalar, Scalar, 1, 1, 1>;

/// Image of vector values
///
/// Here, R indicates the number of rows in the vector
pub type ArcImageR<Scalar, const R: usize> = GenArcImage<3, 1, Scalar, SVec<Scalar, R>, R, 1, 1>;

/// Image of u8 scalars
pub type ArcImageU8 = ArcImage<u8>;
/// Image of u16 scalars
pub type ArcImageU16 = ArcImage<u16>;
/// Image of f32 scalars
pub type ArcImageF32 = ArcImage<f32>;
/// Image of u8 2-vectors
pub type ArcImage2U8 = ArcImageR<u8, 2>;
/// Image of u16 2-vectors
pub type ArcImage2U16 = ArcImageR<u16, 2>;
/// Image of f32 2-vectors
pub type ArcImage2F32 = ArcImageR<f32, 2>;
/// Image of u8 3-vectors
pub type ArcImage3U8 = ArcImageR<u8, 3>;
/// Image of u16 3-vectors
pub type ArcImage3U16 = ArcImageR<u16, 3>;
/// Image of f32 3-vectors
pub type ArcImage3F32 = ArcImageR<f32, 3>;
/// Image of u8 4-vectors
pub type ArcImage4U8 = ArcImageR<u8, 4>;
/// Image of u16 4-vectors
pub type ArcImage4U16 = ArcImageR<u16, 4>;
/// Image of f32 4-vectors
pub type ArcImage4F32 = ArcImageR<f32, 4>;

macro_rules! arc_image {
    ($scalar_rank:literal, $srank:literal) => {
        /// Convert a GenMutImage to an GenArcImage
        ///
        /// If an image is created inside a function and needs to be returned, it is best practice to
        /// return a GenMutImage. The GenMutImage can be converted to an GenArcImage cheaply and efficiently
        /// using ``.into()`` generated by this trait.
        ///
        impl<
                'a,
                Scalar: IsTensorScalar + 'static,
                STensor: IsStaticTensor<Scalar, $srank, ROWS, COLS, BATCH_SIZE> + 'static,
                const ROWS: usize,
                const COLS: usize,
                const BATCH_SIZE: usize,
            > From<GenMutImage<$scalar_rank, $srank, Scalar, STensor, ROWS, COLS, BATCH_SIZE>>
            for GenArcImage<$scalar_rank, $srank, Scalar, STensor, ROWS, COLS, BATCH_SIZE>
            where
            ndarray::Dim<[ndarray::Ix; $scalar_rank]>: ndarray::Dimension,
        {
            fn from(value: GenMutImage<$scalar_rank, $srank, Scalar, STensor, ROWS, COLS, BATCH_SIZE>) -> Self {
                Self::from_mut_image(value)
            }
        }



        impl<
        'a,
                Scalar: IsTensorScalar + 'static,
                STensor: IsStaticTensor<Scalar, $srank, ROWS, COLS, BATCH_SIZE> + 'static,
                const ROWS: usize,
                const COLS: usize,
                const BATCH_SIZE: usize,
            > GenArcImage<$scalar_rank, $srank, Scalar, STensor, ROWS, COLS, BATCH_SIZE>
        {
            /// Convert an GenArcImage to a GenMutImage
            ///
            /// It is best practice to not call this function directly. Instead, use the ``.into()``
            /// method generated by the ``From`` trait.
            pub fn from_mut_image(
                image: GenMutImage<$scalar_rank, $srank, Scalar, STensor, ROWS, COLS, BATCH_SIZE>,
            ) -> Self {
                Self {
                    tensor: ArcTensor::<
                        $scalar_rank,
                        2,
                        $srank,
                        Scalar,
                        STensor,
                        ROWS,
                        COLS,
                        BATCH_SIZE,
                    >::from_mut_tensor(image.mut_tensor),
                }
            }

            /// create a new image from image size and a value
            pub fn from_image_size_and_val(size: ImageSize, val: STensor) -> Self {
                Self {
                    tensor: ArcTensor::<
                        $scalar_rank,
                        2,
                        $srank,
                        Scalar,
                        STensor,
                        ROWS,
                        COLS,
                        BATCH_SIZE,
                    >::from_shape_and_val(size.into(), val),
                }
            }

            /// create a new image from an image view
            pub fn make_copy_from(
                v: &GenImageView<$scalar_rank, $srank, Scalar, STensor, ROWS, COLS, BATCH_SIZE>,
            ) -> Self {
                Self {
                    tensor: ArcTensor::<
                        $scalar_rank,
                        2,
                        $srank,
                        Scalar,
                        STensor,
                        ROWS,
                        COLS,
                        BATCH_SIZE,
                    >::make_copy_from(&v.tensor_view),
                }
            }

            /// create a new image from image size and a slice
            pub fn make_copy_from_size_and_slice(image_size: ImageSize, slice: &'a [STensor]) -> Self {
                GenMutImage::<$scalar_rank, $srank, Scalar, STensor, ROWS, COLS, BATCH_SIZE>
                    ::make_copy_from_size_and_slice(image_size, slice).into()
            }

            /// create a new image from a uniform operator applied to an image view
            pub fn from_map<
            'b,
            const OTHER_HRANK: usize,
            const OTHER_SRANK: usize,
            OtherScalar: IsTensorScalar + 'static,
            OtherSTensor: IsStaticTensor<
                OtherScalar,
                OTHER_SRANK,
                OTHER_ROWS,
                OTHER_COLS,
                OTHER_BATCHES,
            > + 'static,
            const OTHER_ROWS: usize,
            const OTHER_COLS: usize,
            const OTHER_BATCHES: usize,
            F: FnMut(&OtherSTensor)-> STensor
            >(
                v: &'b  GenImageView::<
                'b,
                OTHER_HRANK,
                OTHER_SRANK,
                OtherScalar,
                OtherSTensor,
                OTHER_ROWS,
                OTHER_COLS,
                OTHER_BATCHES,
            >,
                op: F,

            ) -> Self
            where    ndarray::Dim<[ndarray::Ix; OTHER_HRANK]>: ndarray::Dimension,
            TensorView<'b, OTHER_HRANK, 2, OTHER_SRANK, OtherScalar, OtherSTensor, OTHER_ROWS, OTHER_COLS, OTHER_BATCHES>:
              IsTensorView<'b, OTHER_HRANK, 2, OTHER_SRANK, OtherScalar, OtherSTensor, OTHER_ROWS, OTHER_COLS, OTHER_BATCHES>,

            {
                Self {
                    tensor: ArcTensor::<
                        $scalar_rank,
                        2,
                        $srank,
                        Scalar,
                        STensor,
                        ROWS,
                        COLS,
                        BATCH_SIZE,
                    >::from_map(&v.tensor_view, op),
                }
            }

        }

        /// creates an image from a binary operator applied to two image views
        impl<
                'b,
                Scalar: IsTensorScalar + 'static,
                STensor: IsStaticTensor<Scalar, $srank, ROWS, COLS, BATCH_SIZE> + 'static,
                const ROWS: usize,
                const COLS: usize,
                const BATCH_SIZE: usize,
            > Default for GenArcImage<$scalar_rank, $srank, Scalar, STensor, ROWS, COLS, BATCH_SIZE>
        where
            ndarray::Dim<[ndarray::Ix; $scalar_rank]>: ndarray::Dimension,
        {
            fn default() -> Self {
                Self::from_image_size_and_val(ImageSize::default(), STensor::zero())
            }
        }

        impl<
                'b,
                Scalar: IsTensorScalar + 'static,
                STensor: IsStaticTensor<Scalar, $srank, ROWS, COLS, BATCH_SIZE> + 'static,
                const ROWS: usize,
                const COLS: usize,
                const BATCH_SIZE: usize,
            > IsImageView<'b, $scalar_rank, $srank, Scalar, STensor, ROWS, COLS, BATCH_SIZE>
            for GenArcImage<$scalar_rank, $srank, Scalar, STensor, ROWS, COLS, BATCH_SIZE>
        where
            ndarray::Dim<[ndarray::Ix; $scalar_rank]>: ndarray::Dimension,
        {
            fn image_view(
                &'b self,
            ) -> super::image_view::GenImageView<
                '_,
                $scalar_rank,
                $srank,
                Scalar,
                STensor,
                ROWS,
                COLS,
                BATCH_SIZE,
            > {
                GenImageView {
                    tensor_view: self.tensor.view(),
                }
            }



            fn pixel(&'b self, u: usize, v: usize) -> STensor {
                self.tensor.get([v, u])
            }

            fn image_size(&self) -> super::image_view::ImageSize {
                self.image_view().image_size()
            }
        }
    };
}

arc_image!(2, 0);
arc_image!(3, 1);
arc_image!(4, 2);
